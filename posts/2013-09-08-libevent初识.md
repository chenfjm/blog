---
layout: post
title: libevent 初识
category: 网络
description:
---

**Linux IO 模型**

- 阻塞IO
- 非阻塞IO
- IO复用
- 信号驱动IO
- 异步IO

信号驱动IO模型是应用进程告诉内核：当你的数据报准备好的时候，给我发送一个信号哈，并且调用我的信号处理函数来获取数据报，这个模型是由信号进行驱动。   
阻塞调用是指调用结果返回之前，当前线程会被挂起，函数只有在得到结果之后才会返回；非阻塞和阻塞的概念相对应，指在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回。   
同步IO是指在IO操作完成之前会阻塞当前当前调用进程；异步IO是指调用者不能立刻得到结果，实际处理这个调用的部件(内核)在完成后，通过状态、通知和回调来通知调用者。   
按照以上定义，阻塞IO、非阻塞IO、IO复用都属于同步IO。   

**IO复用模式**  

一般地,I/O多路复用机制都依赖于一个事件多路分离器(Event Demultiplexer)。分离器对象可将来自事件源的I/O事件分离出来，并分发到对应的read/write事件处理器(Event Handler)。开发人员预先注册需要处理的事件及其事件处理器（或回调函数）；事件分离器负责将请求事件传递给事件处理器。两个与事件分离器有关的模式是Reactor和Proactor。Reactor模式采用同步IO，而Proactor采用异步IO。  

在Reactor中，事件分离器负责等待文件描述符或socket为读写操作准备就绪，然后将就绪事件传递给对应的处理器，最后由处理器负责完成实际的读写工作。  

而在Proactor模式中，处理器--或者兼任处理器的事件分离器，只负责发起异步读写操作。IO操作本身由操作系统来完成。传递给操作系统的参数需要包括用户定义的数据缓冲区地址和数据大小，操作系统才能从中得到写出操作所需数据，或写入从socket读到的数据。事件分离器捕获IO操作完成事件，然后将事件传递给对应处理器。比如，在windows上，处理器发起一个异步IO操作，再由事件分离器等待IOCompletion事件。典型的异步模式实现，都建立在操作系统支持异步API的基础之上，我们将这种实现称为“系统级”异步或“真”异步，因为应用程序完全依赖操作系统执行真正的IO工作。  

**libevent的作用**   

Linux中默认的socket都是阻塞的，当程序在同一时刻没有其他事情处理时，阻塞IO会工作的很好。但想象一下你的程序需要在同一时刻处理多个连接，阻塞IO就不适合了。一个解决办法是运用多进程或多线程，给每一个连接分配一个进程或线程，然而当你的程序需要处理成百上千的连接时，这种处理方式反而会降低效率，尤其实在某些创建进程和线程比较昂贵的平台上。此时就需要考虑非阻塞IO了，调用非阻塞IO轮寻每一个连接。但是这样会严重影响程序性能，有两个原因。第一，当没有数据到达时，程序会一直空转，占用CPU周期；第二，对每个连接都会进行内核调用。因此我们需要这样一种方法：告诉内核"等待，直到一些连接有数据到达，内核再通知我时哪些连接有数据准备好"。比较旧的解决方法是使用select()调用,由于使用select需要用户去遍历描述符集合以查看操作是否就绪，当描述符非常多时也会影响程序性能。因此不同的操作系统提供了不同的替代函数，包括epoll(linux)、kqueue(the BSDs)、evports(Solaris)等等。当你需要写一个跨平台的且性能高的异步程序时不得不抽象并包装这些接口，还要判断哪个性能较好。然而这正好是libevent底层API为你做的，libevent把这些不同平台的接口包装成简单易用的统一接口以供用户去使用。

**libevent介绍**   

libevent是一个轻量级的开源高性能网络库，是用c语言编写的，采用Reactor模型。  

设计目标：    
  
- 可移植性：使用libevent编写的程序应该可以在libevent支持的所有平台上工作。即使没有好的方式进行非阻塞IO，libevent也应该支持一般的方式，让程序可以在受限的环境中运行。   
- 速度：libevent尝试使用每个平台上最高速的非阻塞IO实现，并且不引入太多的额外开销。   
- 可扩展性：libevent被设计为程序即使需要上万个活动套接字的时候也可以良好工作。   
- 方便：无论何时，最自然的使用libevent编写程序的方式应该是稳定的、可移植的。   
    
组件：   

- evutil：用于抽象不同平台网络实现差异的通用功能。   
- event和event_base：libevent的核心，为各种平台特定的、基于事件的非阻塞IO后端提供抽象API，让程序可以知道套接字何时已经准备好，可以读或者写，并且处理基本的超时功能，检测OS信号。   
- bufferevent：为libevent基于事件的核心提供使用更方便的封装。除了通知程序套接字已经准备好读写之外，还让程序可以请求缓冲的读写操作，可以知道何时IO已经真正发生。（bufferevent接口有多个后端，可以采用系统能够提供的更快的非阻塞IO方式，如Windows中的IOCP。）  
- evbuffer：在bufferevent层之下实现了缓冲功能，并且提供了方便有效的访问函数。  
- evhttp：一个简单的HTTP客户端/服务器实现。  
- evdns：一个简单的DNS客户端/服务器实现。  
- evrpc：一个简单的RPC实现。   

库：  

- ibevent_core：所有核心的事件和缓冲功能，包含了所有的event_base、evbuffer、bufferevent和工具函数。  
- ibevent_extra：定义了程序可能需要，也可能不需要的协议特定功能，包括HTTP、DNS和RPC。  
- libevent：这个库因为历史原因而存在，它包含libevent_core和libevent_extra的内容。不应该使用这个库，未来版本的libevent可能去掉这个库。  
某些平台上可能安装下列库：  
- libevent_pthreads：添加基于pthread可移植线程库的线程和锁定实现。它独立于libevent_core，这样程序使用libevent时就不需要链接到pthread，除非是以多线程方式使用libevent。  
- libevent_openssl：这个库为使用bufferevent和OpenSSL进行加密的通信提供支持。它独立于libevent_core，这样程序使用libevent时就不需要链接到OpenSSL，除非是进行加密通信。  

头文件： 
 
libevent公用头文件都安装在event2目录中，分为三类:

- API头文件：定义libevent公用接口。这类头文件没有特定后缀。  
- 兼容头文件：为已废弃的函数提供兼容的头部包含定义。不应该使用这类头文件，除非是在移植使用较老版本libevent的程序时。  
- 结构头文件：这类头文件以相对不稳定的布局定义各种结构体。这些结构体中的一些是为了提供快速访问而暴露；一些是因为历史原因而暴露。直接依赖这类头文件中的任何结构体都会破坏程序对其他版本libevent的二进制兼容性，有时候是以非常难以调试的方式出现。这类头文件具有后缀“_struct.h”。
